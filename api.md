# Ryle API

1. [State Machine Declaration](#state-machine-declatation)
   1. [Machine Structure](#machine-structure)
   1. [Machine Object](#machine-object)
   1. [Machine Instance](#machine-instance)
1. [Defining a State](#defining-a-state)
   1. [On Entry](#on-entry)
   1. [On Exit](#on-exit)
   1. [Transitions](#transitions)
   1. [Binding Events](#binding-events)
   1. [Hooks](#hooks)
1. [Hierarchical Machines](#hierarchical-machines)
1. [Composable Machines](#composable-machines)
1. [Examples](#examples)
   1. [Countdown](#countdown)
   1. [Long REST](#long-rest)
   1. [Door](#door)

## State Machine Declaration

A state machine is declared, after requiring `ryle`, with:
```javascript
const machineObject = ryle(machineStructure);
```
An active instance of a machine is created with:
```javascript
const machineInstance = machineObject(<params>)
```
The first section below deals with the machine structure, object and instance are described in the following sections.

### Machine Structure
The machine structure passed to `ryle` is a javascript object containing the state definitions.  The only thing it _must_
contain is a getter function called `_start` which returns the initial state.  Clearly the machine is not a lot of use
if it does not also contain any states, however `ryle` will only throw an error in the absence of a `_start`.

So, the simplest structure:
```javascript
const machineObject = ryle({
  get _start(){return this.initial},
  initial(context){
    //state definition
  },
  //other states
});
```
Why must `_start` be a getter rather than just a simple value?  Typically the object passed to `ryle` is anonymous and
using a getter provides a `this` which points to the definition object.  Why not just use strings? For the same reasons
described [here](http://millermedeiros.github.io/js-signals/) for the js-signals library.  In essence, and particularly
for a large state machine, string names can't be checked by your IDE and don't throw an error if they are wrong whereas
returning real object (and using signals instead of events) _can_ be caught by your IDE and _will_ throw an error if you
get them wrong.
### Machine Object
The _machine object_ is a function which can initiate the state machine.  The object has all the states attached which
were supplied with the definition.  For example in the above code block `machineObject.initial` will be the state function.
All of the state functions, and the _machine object_ itself have the following methods:

asd | asd | asd
--- | --- | ---
dfdf | dfdf | dfdf

  target.onEnter = onEnter;
  target.onExit = onExit;
  target.onceActive = onceActive;
  target.getState = getState;
  target.using = using;

### Machine Instance
The instance of the state machine created by the machine object is a promise which resolves when the state machine exits,
or rejects when an uncaught error is thrown (or uncaught promise rejects).  For state machines which are going to
complete a common pattern is:
``` javascript
machineObject(context).then(
  function(result){
    //do something on success!
  }, function (error){
    //something has gone wrong!
  }
)
```
Even for state machines which are not intended to ever complete, it is still advisable to use a `.catch` method to deal
with errors.

In addition to the usual promise methods the instance object has three other members:
- `.context` which is the context passed to, or generated by, the machine object;
- `.machine` which is a reference to the machine object; and
- `.cancel()` which is a method to cause the state machine to make an orderly exit.
## Defining a State
### On Entry
According to the UML definitions a state can have actions performed on entry and on exit and various triggers can cause
transitions from that state to another.  In _ryle_ a state is defined simply as a function which is executed when the
state is entered.  What is returned from that function determines all other properties of the state, and in the simplest
case this is just another state to transition to, for example:
```
...
  state1(context){
    //do stuff here on entry
    //then move on straight away
    return this.state2;
  },
...
```
This is a transitional state.  To define a resting state there needs to be some external event which will trigger a
transition, and to define that we need to use the `ryle` object:
```
...
  state2(context){
    return ryle
      .on(context.start, this.state3)
      .onExit(()=>context.hasStarted=true);
  },
...
```
Here the `ryle` object has a number of chainable methods which are used to define a transition object.  In this case the `.on`
method is used to cause an event to trigger a transition and the `.onExit` method to define what happens when that state exits.
This is the transition object.  The third option is only usually used in a hierarchical machine which is not to return anything
from the state machine.  In this case the machine can only exit this state due to a transition defined elsewhere, for example
`.cancel` method of the machine instance.

### Transition Object
A transition object is returned by a state function to define what can cause a state to exit and what will happen when
it does.  There are three chainable methods of the `ryle` object which generate a transition object, and of those the `.on`
method has many variants:
#### `.onTimeout(<delay>, <state>)`
If, after _delay_ miliseconds nothing else has happened, then the machine will transition to the new _state_.
#### `.onExit(<function>)`
When the state does exit the onExit function (or functions if there are several onExit methods) will execute.  An important
point here is that these are declared in the state function.  If there is a resource which is only needed by a state then
it does not need to be stored on the `context` as the `.onExit` functions will have access to the state function closure.
#### `.on(<boolean>, <state> [, <state>])`
The boolean is evaluated.  If `true` then the first state is transitioned to immediately.  If `false` and if there is a 
second state then that is transitioned to.
#### `.on(<promise>, <state> [, <state>])`
If and when the promise resolves it will transition to the first state with the promise result as the payload.  Similarly
if the promise rejects and there is a second state then that will be transitioned to with the rejection reason as the
payload.  If another transition occurs first then the result of the promise will be discarded.  If the promise rejects
before any other transition *and* there is no second state then _the state machine itself will reject with the error._
#### `on(<variable_param_list>, <state>)`
Finally the `.on` method can be used to listen to a custom event type which can be registerred with *Ryle*.  There are
three of these included:
- 

### Binding Events

### Hooks

## Hierarchical Machines

## Composable Machines
